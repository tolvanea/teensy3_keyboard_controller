//! This module contains utilities for generating keyboard matrix on the first use time. Once that
//! is done, this module is not needed anymore. Keyboard matrix is generated by pressing through
//! every single key in keyboard. The matrix is saved by copy pasting rust source code snippet that
//! is generated by these tools.
//!
//! TODO add example

use heapless::{Vec}; // fixed capacity `std::Vec`
use typenum::{Unsigned, U64 as PinsCap, U256 as KeysCap};  // Maximum capacities

use teensy3::util::{delay};
use teensy3::pins::{PinMode, Pin, PinRow, NUM_PINS, LED_PIN};

use super::{full_vec};
use crate::process_keys::{KeyMatrix, MatrixCap};

/// IDK is this useless?
#[allow(dead_code)]
struct KeyIndices {
    /// Index corresponds rows in matrix, and the value is GPIO port number
    row_to_pin: Vec<usize, MatrixCap>,
    /// Index corresponds columns in matrix, and the value is GPIO port number
    col_to_pin: Vec<usize, MatrixCap>,
    /// The inverses of `row_to_pin`, that is, index corresponds to GPIO port number,
    /// and value corresponds the row in matrix
    pin_to_row: Vec<Option<usize>, PinsCap>,
    /// The inverses of `col_to_pin`
    pin_to_col: Vec<Option<usize>, PinsCap>,
}

impl KeyIndices {
    /// Fetch the keycode with GPIO pin indices. If there is no keycode for that pair,
    /// panic. This should function not be used, as there are better alternatives.
    #[allow(dead_code)]
    fn get(&self, mat: &KeyMatrix, i: usize, j: usize) -> Option<u32> {
        let (i, j) = if i < j { (i, j) } else { (j, i) };  // put in order
        if i < self.pin_to_row.len() || j < self.pin_to_col.len() {
            mat.code_matrix[self.pin_to_row[i]?][self.pin_to_col[j]?]
        } else {
            None  // Out of bounds
        }
    }
}


/// Find out what to pins are electrically connected. This corresponds to key press. Scan pins
/// by iterating ALL possible pin combinations, which is not very efficient, especially if key
/// matrix is known. So use this only when you do not know how many columns and rows key matrix
/// contains.
fn scan_key_press(pinrow: &mut PinRow) -> Option<(usize, usize)>{
    // Connected pins. There should be only ONE pin pair connected
    let mut connection: Option<(usize, usize)> = None;

    assert!(NUM_PINS <= PinsCap::to_usize(), "Allocated memory ran out, too many pins");
    // Set all pins to drain mode, but by default disable them. They will be turned on
    // only to check whether some particular connection exists
    let mut pins: Vec<Pin, PinsCap> = (0..NUM_PINS).filter(|&i| i != LED_PIN)
        .map(|i| {
            let mut p = pinrow.get_pin(i, PinMode::OutputOpenDrain);
            p.digital_write(true);  // By default disable drain
            p
        })
        .collect();
    // Check connections, and set drain pins one by one to source pins.
    for i in 0..pins.len() {
        // Pins [0..i+1] are source pins "i", and [i+1..NUM_PINS] are drain pins "j"
        let (i_pins, j_pins) = pins.split_at_mut(i+1);
        let pin_i = &mut i_pins[i];
        pin_i.set_mode(PinMode::InputPullup);  // Make `pin_i` voltage source
        delay(1);
        for (j, pin_j) in j_pins.iter_mut().enumerate() {
            pin_j.digital_write(false);  // enable drain
            let pressed = !pin_i.digital_read();  // check if `pin_i` and `pin_j` are connected
            pin_j.digital_write(true);  // disable drain
            if pressed {delay(4);}  // It takes time for pullup pin to charge back!

            let i_real_idx = if i < LED_PIN {i} else {i+1};
            let j_real_idx = if i+1+j < LED_PIN {i+1+j} else {i+2+j};
            if pressed {
                if connection == None {
                    connection = Some((i_real_idx, j_real_idx));
                } else {
                    println!("Warning! Multiple connections found: {:?} and {:?}. Ignoring both.",
                             connection.unwrap(), (i_real_idx, j_real_idx));
                    return None;
                }
            }
        }
    }
    pins.into_iter().for_each(|pin| pinrow.return_pin(pin));
    return connection;
}

/// Loops until some key is pressed
fn wait_for_key(pinrow: &mut PinRow) -> (usize, usize) {
    let pair = loop {
        match scan_key_press(pinrow) {
            Some(pair) => {break pair;},
            None => {delay(10);},
        }
    };
    return pair;
}

/// Utility tool that finds out key matrix. User presses through every single key through in
/// keyboard. Keys 'Backspace' and 'Delete' are used to fix typos and other problems in typing
/// prosess. If typo is made, 'Backspace' can be pressed and current row is restarted. If some key
/// does not seem to work, 'Delete' can be pressed, which skips that key, and leaves it out of
/// key matrix.
///
/// To avoid re-configuring key matrix every single time after rebooting, it is useful to store it
/// somehow. This is why function prints key matrix representation as rust plain source code. That
/// code snippet is supposed to be copied to source code, replacing call to this function.
/// Then there is no need to press every single key through again. This procedure may seem a hacky
/// way to store key matrix, but it seems to be the main way to implement it with microcontrollers.

/// # Arguments
/// * `pinrow` :    PinRow singleton
///
/// * `key_codes` : This contains all key codes in same order that they will be pressed.
///                 To make typing process a bit easier, the list is divided in parts so that key
///                 pressing process is also divided in parts. For example, these parts can
///                 correspond to physical rows in key board: (CapsLock, a, s, d, f, ...).
///                 MAKE SURE THAT THE FIRST LIST IN `key_codes` CONTAINS ONLY ENTER AND SPACE.
///                 Like so:
///                 ```
///                 &[
///                   &[KEY_ENTER, KEY_SPACE],
///                   &[KEY_ESC, KEY_F1, KEY_F2, ...],
///                   &[KEY_TILDE, KEY_1, KEY_2, ...],
///                   &[KEY_TAB, KEY_Q, KEY_W, ...],
///                   ...
///                 ]
///                 ```
///                 (Actually first keys need not to be enter and space, but whatever they are,
///                 they will be used as error handling keys described above.)
///
/// * `key_names`:  This is similar list to `key_codes`, but contains the names of keys. It's
///                 recommended to use names that correspond to keycode definitions. For example, key
///                 'A' could be named as "bindings::KEY_A", where `bindings::KEY_A` is rust source
///                 code name for constant corresponding to key code of A. Key matrix is printed
///                 with these key names, and if they are valid rust code, then whole key matrix
///                 can be directly copy pasted to source code. These names are also printed for
///                 each query in the key configuration process.
#[allow(dead_code)]
pub fn figure_out_key_matrix<'a>(
    pinrow: &mut PinRow,
    key_codes: &[&[u32]],
    key_names: &[&[&'a str]]
) -> KeyMatrix
{
    assert!(key_codes[0].len() == 2,
        r#"First list in `key_codes` should contain only Enter and Space.\n\
        The list may look something like the following:\n\
        `&[\
            &[KEY_ENTER, KEY_SPACE], \n\
            &[KEY_ESC, KEY_F1, KEY_F2, ...], \n\
            &[KEY_TILDE, KEY_1, KEY_2, ...],\n\
            &[KEY_TAB, KEY_Q, KEY_W, ...],\n\
            ...
         ]`"#);
    assert!(key_codes.len() == key_names.len(), "`key_codes` and `key_names` have different size.");
    let same_size = key_codes.iter().zip(key_names.iter())
        .all(|(&row_code, &row_name)| row_code.len() == row_name.len());
    assert!(same_size, "`key_codes` and `key_names` must correspond to each other in row lengths.");
    let mut keys: Vec<(usize, usize, u32, &str), KeysCap> = Vec::new();

    let key_codes_len = key_codes.len();
    let mut key_codes_itr = key_codes.iter();
    let mut key_names_itr= key_names.iter();

    // Get pins corresponding first two keys in list. These are reserved for special purpose
    let (backspace, delete) = {
        let codes = key_codes_itr.next().unwrap();
        let names = key_names_itr.next().unwrap();
        let helps = [
            "This key can be used to fix typos, and it will restart the row.",
            "If some key does not work, this key can be used to skip it.",
        ];
        for ((&code, &name), &h) in codes.iter().zip(names.iter()).zip(helps.iter()) {
            print!("Press '{}'. {} ", name, h);
            let (i, j) = wait_for_key(pinrow);
            println!("Ok.");
            keys.push((i, j, code, name)).unwrap();
            delay(200);
        }
        let backspace = (keys[0].0, keys[0].1);
        let delete = (keys[1].0, keys[1].1);
        assert!(backspace != delete, "These two keys can not be the same!");
        println!("First row of keycodes successfully processed.");
        (backspace, delete)
    };

    println!("Each key is queried one key at a time. The order corresponds input parameters.");
    for (row_idx, (&row_code, &row_name)) in key_codes_itr
        .zip(key_names_itr).enumerate() {
        println!("Starting row {}/{}, which consists total of {} keys.",
                 row_idx+2, key_codes_len, row_code.len());
        let old_len = keys.len();
        'ask: loop {  // Ask same row of keys until no typos are made.
            for (key_idx, (&key_code, &key_name)) in row_code.iter()
                .zip(row_name).enumerate() {
                delay(100);
                print!("     Press key {}/{}: {}. ", key_idx+1, row_code.len(), key_name);
                let pair = wait_for_key(pinrow);
                if pair == delete {                                     // Skip key if it is broken
                    println!("Skipping that key.");
                } else if pair == backspace {                           // Restart if typo is made
                    println!("Restarting the whole row again.");
                    keys.resize(old_len, (0,0,0,"")).unwrap();
                    continue 'ask;
                } else if keys.iter().any(|&(i, j, _, _)| (i,j) == pair) {  // Same key twice
                    println!("That key has been already pressed! Restarting the whole row again.");
                    keys.resize(old_len, (0,0,0,"")).unwrap();
                    continue 'ask;
                } else if keys.len() + 1 == KeysCap::to_usize() {       // Overflow
                    panic!("Maximum number of keys exceeded. ({})", KeysCap::to_usize())
                } else {                                                // Successful key press
                    println!("Check.");
                    keys.push((pair.0, pair.1, key_code, key_name)).unwrap();
                }
            }
            break;
        }
    }
    // Find out input pins and output pins
    // row_to_pin: Index is row in matrix and value is pin number
    let mut row_to_pin: Vec<usize, MatrixCap> = Vec::new();
    // col_to_pin: Index is column in matrix and value is pin number
    let mut col_to_pin: Vec<usize, MatrixCap> = Vec::new();

    let mut pins: Vec<Option<usize>, PinsCap> = Vec::new();
    for &(i, j, _, _) in keys.iter() {
        assert_ne!(i, j);
        assert!(
            pins.len() <= PinsCap::to_usize(),
            "Too many pins found (>16), allocated memory ran out."
        );
        let (i_in_pins, j_in_pins) = pins.iter().map(|p| p.unwrap()).fold(
            (false, false),
            |(acc_i, acc_j), pin| (acc_i || (i == pin), acc_j || (j == pin))
        );
        if !i_in_pins {
            pins.push(Some(i)).unwrap();
        }
        if !j_in_pins {
            pins.push(Some(j)).unwrap();
        }
    }

    // Classify one pin as row pin, and let the rest be determined by that.
    row_to_pin.push(pins.pop().unwrap().unwrap()).unwrap();

    fn contains<T: PartialEq, I: Iterator<Item=T>>(mut iter: I, val: T) -> bool {
        iter.any(|x| x==val)
    }

    let mut passed_one_round_and_found_nothing = false;

    // Classify `pins` to two groups: `row_to_pin` and `col_to_pin`
    'l: loop {
        if pins.iter().all(|p| p.is_none()) {
            break; // No more pins to classify, job done
        }
        let unclassified_pins = pins.iter_mut().filter(|p| p.is_some());

        // take first unclassified pin from list and replace it with None.
        for (idx, unclassified_pin) in unclassified_pins.enumerate() {
            let pin = unclassified_pin.unwrap();

            // Iterate connection-pairs and collect corresponding pins for this particular pin
            let mut pin_pairs: Vec<usize, PinsCap> = Vec::new();
            for &(i, j, _, _) in keys.iter(){
                if i == pin {
                    pin_pairs.push(j).unwrap();
                } else if j == pin {
                    pin_pairs.push(i).unwrap();
                }
            }
            enum PinType {
                RowPin,
                ColPin,
                Neither,
            }
            use PinType::*;
            let mut typ = Neither;
            for row_pin in row_to_pin.iter() {
                if contains(pin_pairs.iter(), row_pin) {
                    match typ {
                        RowPin => { panic!("Error, some pin is both source and drain."); },
                        ColPin => {},
                        Neither => { typ = ColPin; println!("{} will be classified as Col", pin);},
                    }
                }
            }
            for col_pin in col_to_pin.iter() {
                if contains(pin_pairs.iter(), col_pin) {
                    match typ {
                        RowPin => {},
                        ColPin => { panic!("Error, some pin is both source and drain."); },
                        Neither => { typ = RowPin; println!("{} will be classified as Row", pin);},
                    }
                }
            }
            let container = match typ {
                RowPin => &mut row_to_pin,
                ColPin => &mut col_to_pin,
                Neither => {
                    // If all pins are already iterated through, and no constraints is found, then
                    // it does not matter where the first pin is classified. So choose then freely
                    // whether it is row or column pin.
                    if (idx == 0) && passed_one_round_and_found_nothing {
                        println!("Iterated all through and it does not matter for {}", pin);
                        if row_to_pin.len() < col_to_pin.len() {
                            &mut row_to_pin
                        } else {
                            &mut col_to_pin
                        }
                    } else {
                        continue // keep iterating
                    }
                },
            };
            container.push(pin).unwrap();
            *unclassified_pin = None;
            continue 'l;
        }
        passed_one_round_and_found_nothing = true;
    }

    // assure that i is always row index and j column index
    for (i, j, _, _) in keys.iter_mut() {
        let (i_in_rows, j_in_rows) = row_to_pin.iter().fold(
            (false, false),
            |(acc_i, acc_j), &pin| (acc_i || (*i == pin), acc_j || (*j == pin))
        );
        let (i_in_cols, j_in_cols) = col_to_pin.iter().fold(
            (false, false),
            |(acc_i, acc_j), &pin| (acc_i || (*i == pin), acc_j || (*j == pin))
        );

        assert!((i_in_rows && j_in_cols) || (i_in_cols && j_in_rows));

        if i_in_cols && j_in_rows {
            core::mem::swap(i, j);
        }
    }

    // if false {
    //     for (i, j, _, name) in keys.iter_mut() {
    //         assert!(
    //             row_to_pin.len() <= MatrixCap::to_usize() && col_to_pin.len() <= MatrixCap::to_usize()
    //             , "Too many pins found (>16), allocated memory ran out."
    //         );
    //         assert_ne!(*i, *j);
    //         println!("{:?}", (*i, *j));
    //
    //         let (i_in_rows, j_in_rows) = row_to_pin.iter().fold(
    //             (false, false),
    //             |(acc_i, acc_j), &pin| (acc_i || (*i == pin), acc_j || (*j == pin))
    //         );
    //         let (i_in_cols, j_in_cols) = col_to_pin.iter().fold(
    //             (false, false),
    //             |(acc_i, acc_j), &pin| (acc_i || (*i == pin), acc_j || (*j == pin))
    //         );
    //
    //         if !i_in_rows && !i_in_cols {
    //             row_to_pin.push(*i).unwrap();
    //         }
    //         if !j_in_rows && !j_in_cols {
    //             col_to_pin.push(*j).unwrap();
    //         }
    //
    //         assert!(
    //             !(i_in_cols && j_in_cols) && !(i_in_rows && j_in_rows),
    //             "Error, some pin is both source and drain at the same time.\n\
    //         pin: {:?}, key name: {:?}\n\
    //         source pins so far: {:?}\n\
    //         drain pins so far: {:?}", (*i, *j), name, row_to_pin, col_to_pin
    //         );
    //
    //         // if i and j are flipped then flip them back
    //         if i_in_cols || j_in_rows {
    //             core::mem::swap(i, j);
    //         }
    //     }
    // }

    // Sort them. (Syntax is ugly because vector is sorted by using slice cast.)
    AsMut::<[usize]>::as_mut(&mut row_to_pin).sort_unstable();
    AsMut::<[usize]>::as_mut(&mut col_to_pin).sort_unstable();

    // The inverses of `row_to_pin` and `col_to_pin`.
    // That is, index corresponds index of pin, and value corresponds the row/column in matrix
    let mut pin_to_row: Vec<Option<usize>, PinsCap> = full_vec(None, NUM_PINS);
    let mut pin_to_col: Vec<Option<usize>, PinsCap> = full_vec(None, NUM_PINS);

    for (row, &pin) in row_to_pin.iter().enumerate() {
        pin_to_row[pin] = Some(row);
    }
    for (col, &pin) in col_to_pin.iter().enumerate() {
        pin_to_col[pin] = Some(col);
    }

    assert!(
        row_to_pin.enumerate().iter().all(|(i, &pin)| i==pin_to_row[pin].unwrap())
            && col_to_pin.enumerate().iter().all(|(i, &pin)| i==col_to_row[pin].unwrap()),
        "Internal error! Pin inverse vec is wrong."
    );
    assert!(
        row_to_pin.iter().all(|&pin| pin_to_col[pin].is_none())
            && col_to_pin.iter().all(|&pin| pin_to_row[pin].is_none()),
        "Internal error! Overlap with input and output pins."
    );

    let mut code_matrix: Vec<Vec<Option<u32>, MatrixCap>, MatrixCap>
        = full_vec(full_vec(None, col_to_pin.len()), row_to_pin.len());
    let mut name_matrix: Vec<Vec<Option<&str>, MatrixCap>, MatrixCap>
        = full_vec(full_vec(None, col_to_pin.len()), row_to_pin.len());
    let mut column_max_width: Vec<usize, MatrixCap>  // Width for each column for pretty printing
        = full_vec(usize::MIN, col_to_pin.len());

    for &(i, j, code, name) in keys.iter() {
        let i_idx = pin_to_row[i].unwrap();
        let j_idx = pin_to_col[j].unwrap();
        let code_cell = &mut code_matrix[i_idx][j_idx];
        let name_cell = &mut name_matrix[i_idx][j_idx];
        assert!(name_cell.is_none(), "Clash for same matrix item! ({},{}) {} and {}",
                i, j, name_cell.unwrap(), name);  // This is checked before, should never happen
        *code_cell = Some(code);
        *name_cell = Some(name);
        column_max_width[j_idx] = usize::max(column_max_width[j_idx], name.len());
    }


    println!("Here's key matrix. You can copy-paste it to source code.\n");
    println!("let code_matrix = [");
    for row in name_matrix.iter() {
        print!("    [");
        for (name, width) in row.iter().zip(column_max_width.iter()) {
            print!("{name:>width$}, ", name=name.unwrap_or("0"), width=width);
        }
        println!("],");
    }
    println!("];");
    println!("let rows = {:?};", row_to_pin);
    println!("let cols = {:?};", col_to_pin);
    println!("let mat = KeyMatrix::new(pinrow, code_matrix, rows, cols)");

    let mat = KeyMatrix::new(pinrow, code_matrix, row_to_pin, col_to_pin);
    return mat;
}
