//! This module contains utilities for generating keyboard matrix on the first use time. Once that
//! is done, this module is not needed anymore. Keyboard matrix is generated by pressing through
//! every single key in keyboard. The matrix is saved by copy pasting rust source code snippet that
//! is generated by these tools.

use heapless::Vec; // fixed capacity `std::Vec`
use typenum::{Unsigned, U64 as PinsCap, U256 as KeysCap};  // Maximum capacities

use teensy3::{util::delay, pins::{PinMode, Pin, PinRow, NUM_PINS, LED_PIN}};

use crate::{full_vec, ShortVec, Contains};
use crate::process_keys::{KeyMatrix, ExtraKeyInfo};

/// Utility tool that finds out key matrix. User presses through every single key through in
/// keyboard. Keys 'Backspace' and 'Delete' are used to fix typos and other problems in typing
/// prosess. If typo is made, 'Backspace' can be pressed and current row is restarted. If some key
/// does not seem to work, 'Delete' can be pressed, which skips that key, and leaves it out of
/// key matrix.
///
/// To avoid re-configuring key matrix every single time after rebooting, it is useful to store it
/// somehow. This is why function prints key matrix representation as rust plain source code. That
/// code snippet is supposed to be copied to source code, replacing call to this function.
/// Then there is no need to press every single key through again. This procedure may seem a hacky
/// way to store key matrix, but it seems to be the main way to implement it with microcontrollers.
/// # Arguments
/// * `pinrow` :    PinRow singleton
///
/// * `key_codes` : This contains all key codes in same order that they will be pressed.
///                 To make typing process a bit easier, the list is divided in parts so that key
///                 pressing process is also divided in parts. For example, these parts can
///                 correspond to physical rows in key board: (CapsLock, a, s, d, f, ...).
///                 MAKE SURE THAT THE FIRST LIST IN `key_codes` CONTAINS ONLY BACKSPACE AND DELETE.
///                 Like so:
///                 ```
///                 &[
///                   &[KEY_BACKSPACE, KEY_DELETE],
///                   &[KEY_ESC, KEY_F1, KEY_F2, ...],
///                   &[KEY_TILDE, KEY_1, KEY_2, ...],
///                   &[KEY_TAB, KEY_Q, KEY_W, ...],
///                   ...
///                 ]
///                 ```
///                 (Actually first keys need not to be backspace and delete, but whatever they are,
///                 they will be used as error handling keys described above.)
///
/// * `key_names`:  This is similar list to `key_codes`, but contains the names of keys. It's
///                 recommended to use names that correspond to keycode definitions. For example,
///                 key 'A' could be named as "bindings::KEY_A", where `bindings::KEY_A` is rust
///                 source code name for constant corresponding to key code of A. Key matrix is
///                 printed with these key names, and if they are valid rust code, then whole key
///                 matrix can be directly copy pasted to source code. These names are also printed
///                 for each query in the key configuration process.
///
/// * `info`:       Small extra information about key codes needed to control keyboard. See
///                 `extra_information_about_key_codes` for more.
///
/// # Examples
/// ```
/// use teensy3::bindings as b;
/// use crate::custom_key_codes::extra_information_about_key_codes;
/// use crate::record_keyboard_matrix::figure_out_key_matrix;
///
/// const KEY_NAMES_SHORT_TEST: &[&[&str]] = &[
///     &["b::KEY_BACKSPACE", "b::KEY_DELETE"],
///     &["b::KEY_Q", "b::KEY_W", "b::KEY_R"],
///     &["b::KEY_A", "b::KEY_S", "b::KEY_D"],
/// ];
///
/// const KEY_CODES_SHORT_TEST: &[&[u32]] = &[
///     &[b::KEY_BACKSPACE, b::KEY_DELETE],
///     &[b::KEY_Q, b::KEY_W, b::KEY_R],
///     &[b::KEY_A, b::KEY_S, b::KEY_D],
/// ];
///
/// let mut pinrow = unsafe{ PinRow::new_once()};
/// let info = extra_information_about_key_codes();
/// let mat = figure_out_key_matrix(&mut pinrow, KEY_CODES, KEY_NAMES, info);
/// ```
#[allow(dead_code)]
pub fn figure_out_key_matrix<'a>(
    pinrow: &mut PinRow,
    key_codes: &[&[u32]],
    key_names: &[&[&'a str]],
    info: ExtraKeyInfo,
) -> KeyMatrix
{
    let mut keys = query_keys_from_user(pinrow, key_codes, key_names);
    let (mut row_pins, mut col_pins) = separate_pins_to_rows_and_columns(&mut keys);
    let code_matrix = build_and_print_code_matrix(&mut keys, &mut row_pins, &mut col_pins);
    let mat = KeyMatrix::new(pinrow, code_matrix, row_pins, col_pins, info);
    return mat;
}

fn query_keys_from_user<'a>(
    pinrow: &mut PinRow,
    key_codes: &[&[u32]],
    key_names: &[&[&'a str]]
) -> Vec<(usize, usize, u32, &'a str), KeysCap> {
    assert_eq!(key_codes[0].len(), 2,
        "First row in `key_codes` should contain only two keys, e.g. Backspace and Delete, \n\
        which are used as controls. The key_codes should look something like the following:\n\
        ```\n\
        let key_codes = &[\n    \
            &[KEY_BACKSPACE, KEY_DELETE], \n    \
            &[KEY_ESC, KEY_F1, KEY_F2, ...], \n    \
            &[KEY_TILDE, KEY_1, KEY_2, ...],\n    \
            &[KEY_TAB, KEY_Q, KEY_W, ...],\n    \
            ...\n\
         ]\n\
         ```"
    );
    assert!(key_codes.len() == key_names.len(), "`key_codes` and `key_names` have different size.");
    let same_size = key_codes.iter().zip(key_names.iter())
        .all(|(&row_code, &row_name)| row_code.len() == row_name.len());
    assert!(same_size, "`key_codes` and `key_names` must correspond to each other in row lengths.");
    let mut keys: Vec<(usize, usize, u32, &str), KeysCap> = Vec::new();

    let key_codes_len = key_codes.len();
    let mut key_codes_itr = key_codes.iter();
    let mut key_names_itr= key_names.iter();

    // Get pins corresponding first two keys in list. These are reserved for special purpose
    let (backspace, delete) = {
        let codes = key_codes_itr.next().unwrap();
        let names = key_names_itr.next().unwrap();
        let helps = [
            "This key can be used to fix typos, and it will restart the row.",
            "If some key does not work, this key can be used to skip it.",
        ];
        for ((&code, &name), &h) in codes.iter().zip(names.iter()).zip(helps.iter()) {
            print!("Press '{}'. {} ", name, h);
            let (i, j) = wait_for_key(pinrow);
            println!("Ok.");
            keys.push((i, j, code, name)).unwrap();
            delay(200);
        }
        let backspace = (keys[0].0, keys[0].1);
        let delete = (keys[1].0, keys[1].1);
        assert!(backspace != delete, "These two keys can not be the same!");
        println!("First row of keycodes successfully processed.");
        (backspace, delete)
    };

    println!("Each key is queried one key at a time. The order corresponds input parameters.");
    for (row_idx, (&row_code, &row_name)) in key_codes_itr
        .zip(key_names_itr).enumerate() {
        println!("Starting row {}/{}, which consists total of {} keys.",
                 row_idx+2, key_codes_len, row_code.len());
        let old_len = keys.len();
        'ask: loop {  // Ask same row of keys until no typos are made.
            for (key_idx, (&key_code, &key_name)) in row_code.iter()
                .zip(row_name).enumerate() {
                delay(200);
                print!("     Press key {}/{}: {} ", key_idx+1, row_code.len(), key_name);
                let pair = wait_for_key(pinrow);
                if pair == delete {                                     // Skip key if it is broken
                    println!("Skipping that key.");
                } else if pair == backspace {                           // Restart if typo is made
                    println!("Restarting the whole row again.");
                    keys.resize(old_len, (0,0,0,"")).unwrap();
                    continue 'ask;
                } else if keys.iter().any(|&(i, j, _, _)| (i,j) == pair) {  // Same key twice
                    println!("That key has been already pressed! Restarting the whole row again.");
                    keys.resize(old_len, (0,0,0,"")).unwrap();
                    continue 'ask;
                } else if keys.len() + 1 == KeysCap::to_usize() {       // Overflow
                    panic!("Maximum number of keys exceeded. ({})", KeysCap::to_usize())
                } else {                                                // Successful key press
                    println!("Check.");
                    keys.push((pair.0, pair.1, key_code, key_name)).unwrap();
                }
            }
            break;
        }
    }
    return keys;
}


/// Find out what to pins are electrically connected. This corresponds to key press. Scan pins
/// by iterating ALL possible pin combinations, which is not very efficient, especially if key
/// matrix is known. So use this only when you do not know how many columns and rows key matrix
/// contains.
pub fn scan_key_press(pinrow: &mut PinRow) -> Option<(usize, usize)>{
    // Connected pins. There should be only ONE pin pair connected
    let mut connection: Option<(usize, usize)> = None;

    assert!(NUM_PINS <= PinsCap::to_usize(), "Allocated memory ran out, too many pins");
    // Set all pins to drain mode, but by default disable them. They will be turned on
    // only to check whether some particular connection exists
    let mut pins: Vec<Pin, PinsCap> = (0..NUM_PINS).filter(|&i| i != LED_PIN)
        .map(|i| {
            let mut p = pinrow.get_pin(i, PinMode::OutputOpenDrain);
            p.digital_write(true);  // By default disable drain
            p
        })
        .collect();
    // Check connections, and set drain pins one by one to source pins.
    'l: for i in 0..pins.len() {
        // Pins [0..i+1] are source pins "i", and [i+1..NUM_PINS] are drain pins "j"
        let (i_pins, j_pins) = pins.split_at_mut(i+1);
        let pin_i = &mut i_pins[i];
        pin_i.set_mode(PinMode::InputPullup);  // Make `pin_i` voltage source
        delay(1);
        for (j, pin_j) in j_pins.iter_mut().enumerate() {
            pin_j.digital_write(false);  // enable drain
            let pressed = !pin_i.digital_read();  // check if `pin_i` and `pin_j` are connected
            pin_j.digital_write(true);  // disable drain
            if pressed {delay(4);}  // It takes time for pullup pin to charge back!

            let i_real_idx = if i < LED_PIN {i} else {i+1};
            let j_real_idx = if i+1+j < LED_PIN {i+1+j} else {i+2+j};
            if pressed {
                if connection == None {
                    connection = Some((i_real_idx, j_real_idx));
                } else {
                    println!("Warning! Multiple connections found: {:?} and {:?}. Ignoring both.",
                             connection.unwrap(), (i_real_idx, j_real_idx));
                    connection = None;
                    break 'l;
                }
            }
        }
    }
    pins.into_iter().for_each(|pin| pinrow.return_pin(pin));
    return connection;
}

/// Loops until some key is pressed
pub fn wait_for_key(pinrow: &mut PinRow) -> (usize, usize) {
    let pair = loop {
        match scan_key_press(pinrow) {
            Some(pair) => {break pair;},
            None => {delay(10);},
        }
    };
    return pair;
}


/// Separate pins to inputs and outputs (i.e. sources and drains). This is not as easy task
/// as it may first appear. The separation for pin must be consistent within all other pins.
/// The task is accomplished with O(n^3) algorithm, which sweeps pins over and over again,
/// and classifies pins to rows or columns if it is known that the counterpart is row/column.
/// Sometimes pin can be chosen either way without contradictions, and then classification is
/// done to balance row/column count.
fn separate_pins_to_rows_and_columns(
    keys: &mut Vec<(usize, usize, u32, &str), KeysCap>
) -> (ShortVec<usize>, ShortVec<usize>){
    // row_pins: Index is row in matrix and value is pin number
    let mut row_pins: ShortVec<usize> = Vec::new();
    // col_pins: Index is column in matrix and value is pin number
    let mut col_pins: ShortVec<usize> = Vec::new();

    let mut pins: Vec<Option<usize>, PinsCap> = Vec::new();
    for &(i, j, _, _) in keys.iter() {
        assert_ne!(i, j);
        assert!(
            pins.len() <= PinsCap::to_usize(),
            "Too many pins found (>64), allocated memory ran out."
        );
        let (i_in_pins, j_in_pins) = pins.iter().map(|p| p.unwrap()).fold(
            (false, false),
            |(acc_i, acc_j), pin| (acc_i || (i == pin), acc_j || (j == pin))
        );
        if !i_in_pins {
            pins.push(Some(i)).unwrap();
        }
        if !j_in_pins {
            pins.push(Some(j)).unwrap();
        }
    }

    // Classify one pin as row pin, and let the rest be determined by that.
    row_pins.push(pins.pop().unwrap().unwrap()).unwrap();

    let counterparts: Vec<ShortVec<usize>, PinsCap> = pins.iter()
        .map(
            |&p| keys.iter()
                .filter_map(|&(i, j, _, _)|
                    if i==p.unwrap() {
                        Some(j)
                    } else if j==p.unwrap() {
                        Some(i)
                    } else {
                        None
                    })
                .collect()
        ).collect();

    let mut passed_one_round_and_found_nothing = false;

    // Classify `pins` to two groups: `row_pins` and `col_pins`
    'l: loop {
        if pins.iter().all(|p| p.is_none()) {
            break; // No more pins to classify, job done
        }
        let unclassified_pins = pins.iter_mut().enumerate().
            filter(|(_, p)| p.is_some());

        // take first unclassified pin from list and replace it with None.
        for (unclassified_idx, (total_idx, unclassified_pin)) in unclassified_pins.enumerate() {
            let pin = unclassified_pin.unwrap();

            enum PinType {
                RowPin,
                ColPin,
                Neither,
            }
            use PinType::*;
            let mut typ = Neither;
            for row_pin in row_pins.iter() {
                if counterparts[total_idx].iter().contains(row_pin) {
                    match typ {
                        RowPin => { panic!("Error, some pin is both source and drain."); },
                        ColPin => {},
                        Neither => { typ = ColPin; },
                    }
                }
            }
            for col_pin in col_pins.iter() {
                if counterparts[total_idx].iter().contains(col_pin) {
                    match typ {
                        RowPin => {},
                        ColPin => { panic!("Error, some pin is both source and drain."); },
                        Neither => { typ = RowPin; },
                    }
                }
            }
            let container = match typ {
                RowPin => &mut row_pins,
                ColPin => &mut col_pins,
                Neither => {
                    // If all pins are already iterated through, and no constraints is found, then
                    // it does not matter where the first pin is classified. So choose then freely
                    // whether it is row or column pin.
                    if (unclassified_idx == 0) && passed_one_round_and_found_nothing {
                        if row_pins.len() < col_pins.len() {
                            &mut row_pins
                        } else {
                            &mut col_pins
                        }
                    } else {
                        continue // keep iterating
                    }
                },
            };
            container.push(pin).unwrap_or_else(|_| panic!(
                "Number of pins {} overflowed the maximum of key matrix dimension {}.",
                container.capacity(), container.len()
            ));
            *unclassified_pin = None;
            continue 'l;
        }
        passed_one_round_and_found_nothing = true;
    }

    // assure that i is always row index and j column index
    for (i, j, _, _) in keys.iter_mut() {
        let (i_in_rows, j_in_rows) = row_pins.iter().fold(
            (false, false),
            |(acc_i, acc_j), &pin| (acc_i || (*i == pin), acc_j || (*j == pin))
        );
        let (i_in_cols, j_in_cols) = col_pins.iter().fold(
            (false, false),
            |(acc_i, acc_j), &pin| (acc_i || (*i == pin), acc_j || (*j == pin))
        );

        assert!((i_in_rows && j_in_cols) || (i_in_cols && j_in_rows),
                "{} {} {} {}", i_in_rows, j_in_cols, i_in_cols, j_in_rows);

        if i_in_cols && j_in_rows {
            core::mem::swap(i, j);
        }
    }

    // Sort them. (Syntax is ugly because vector is sorted by using slice cast.)
    AsMut::<[usize]>::as_mut(&mut row_pins).sort_unstable();
    AsMut::<[usize]>::as_mut(&mut col_pins).sort_unstable();

    return (row_pins, col_pins)
}


fn build_and_print_code_matrix(
    keys: &mut Vec<(usize, usize, u32, &str), KeysCap>,
    row_pins: &mut ShortVec<usize>,
    col_pins: &mut ShortVec<usize>,
) -> ShortVec<ShortVec<Option<u32>>> {
    // The inverses of `row_pins` and `col_pins`.
    // That is, index corresponds index of pin, and value corresponds the row/column in matrix
    let mut pin_rows: Vec<Option<usize>, PinsCap> = full_vec(None, NUM_PINS);
    let mut pin_cols: Vec<Option<usize>, PinsCap> = full_vec(None, NUM_PINS);

    for (row, &pin) in row_pins.iter().enumerate() {
        pin_rows[pin] = Some(row);
    }
    for (col, &pin) in col_pins.iter().enumerate() {
        pin_cols[pin] = Some(col);
    }

    assert!(
        row_pins.iter().enumerate().all(|(i, &pin)| i== pin_rows[pin].unwrap())
            && col_pins.iter().enumerate().all(|(i, &pin)| i== pin_cols[pin].unwrap()),
        "Internal error! Pin inverse vec is wrong."
    );
    assert!(
        row_pins.iter().all(|&pin| pin_cols[pin].is_none())
            && col_pins.iter().all(|&pin| pin_rows[pin].is_none()),
        "Internal error! Overlap with input and output pins."
    );

    let mut code_matrix: ShortVec<ShortVec<Option<u32>>>
        = full_vec(full_vec(None, col_pins.len()), row_pins.len());
    let mut name_matrix: ShortVec<ShortVec<Option<&str>>>
        = full_vec(full_vec(None, col_pins.len()), row_pins.len());
    let mut column_max_width: ShortVec<usize>  // Width for each column for pretty printing
        = full_vec(usize::MIN, col_pins.len());

    for &(i, j, code, name) in keys.iter() {
        let i_idx = pin_rows[i].unwrap();
        let j_idx = pin_cols[j].unwrap();
        let code_cell = &mut code_matrix[i_idx][j_idx];
        let name_cell = &mut name_matrix[i_idx][j_idx];
        assert!(name_cell.is_none(), "Clash for same matrix item! ({},{}) {} and {}",
                i, j, name_cell.unwrap(), name);  // This is checked before, should never happen
        *code_cell = Some(code);
        *name_cell = Some(name);
        column_max_width[j_idx] = usize::max(column_max_width[j_idx], name.len());
    }


    println!("Here's key matrix. You can copy-paste it to source code.\n");
    println!("let code_matrix = [");
    for row in name_matrix.iter() {
        print!("    [");
        for (name, width) in row.iter().zip(column_max_width.iter()) {
            print!("{name:>width$}, ", name=name.unwrap_or("0"), width=width);
        }
        println!("],");
    }
    println!(
        "].iter()\n    \
            .map(|v| v.iter().map(|&k| if k==0 {{ None }} else {{ Some(k) }}).collect())\n    \
            .collect();\n\
        let rows = Vec::from_slice(&{:?}).unwrap();\n\
        let cols = Vec::from_slice(&{:?}).unwrap();\n\
        let mat = KeyMatrix::new(pinrow, code_matrix, rows, cols);",
        row_pins, col_pins);
    return code_matrix;
}
